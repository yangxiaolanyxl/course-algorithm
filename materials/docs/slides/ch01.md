# 第1章 概述

## 1.1 引言

算法是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法描述解决问题的策略机制。

也就是说，能够对一定规范的输入，在有限时间内获得所要求的输出。如果一个算法有缺陷，或不适合于某个问题，执行这个算法将不会解决这个问题。

同一问题可用不同算法解决，而一个算法的质量优劣将影响到算法乃至程序的效率。算法分析的目的在于选择合适算法和改进算法。

一个算法的评价主要从**时间复杂度**和**空间复杂度**来考虑。

一个算法应该具有以下五个重要的特征：

1. **有穷性** --- 执行有限条指令后一定要终止。
2. **确定性(无二义)** --- 算法的每一步操作都必须有确切定义，不得有任何歧义性。
3. **可(能)行性** --- 算法的每一步操作都必须是可行的，即每步操作均能在有限时间内完成。
4. **输入** --- 一个算法有$$n(n>=0)$$个初始数据的输入。
5. **输出** --- 一个算法有一个或多个与输入有某种关系的有效信息的输出。


## 1.2 时间复杂度

一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道。但我们不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。并且一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。

我们把**问题的规模**称之为  $$n$$ ，例如排序问题中 $$n$$ 为排序元素个数、图的问题中 $$n$$ 是图的顶点数、矩阵中的 $$n$$ 为矩阵的阶数等，当 $$n$$ 不断变化时，花费时间也会不断变化，当我们想知道它变化时呈现什么规律时，我们引入时间复杂度概念。 

一般情况下，算法中基本操作重复执行的次数是问题规模 $$n$$ 的某个函数$$f(n)$$，算法的时间度量记作
$$
T(n) = O(f(n))
$$
表示随着问题规模 $$n$$ 的增大，算法执行时间的增长率和 $$f(n)$$ 的增长率相同，称作算法的**渐进时间复杂度**，简称**时间复杂度**。

## 1.3 时间复杂度推导原则

1. 如果运行时间是常数量级，用常数1表示；
2. 只保留时间函数中的最高阶项；
3. 如果最高阶项存在，则省去最高阶项前面的系数。

## 1.4 例题

> 问题：一个有序数组A，另一个无序数组B，请打印B中的所有不在A中的数，A数组长度为N，B数组长度为M。

- 算法1：对于数组B中的每一个数，都在A中通过遍历的方式找一下。

- 算法2：对于数组B中的每一个数，都在A中通过二分的方式找一下。

- 算法3：先把数组B排序，然后用类似外排的方式打印所有不在A中出现的数。

时间复杂度：

- 算法1时间复杂度：$$O(M*N)$$
- 算法2时间复杂度：$$O(M*\log_2^N)$$
- 算法3时间复杂度：$$O(M*\log_2^M + M + N)$$

  - 对数组A中M个数排序时间复杂度：$$O(M*\log_2^M)$$

  - 类似于外排方式打印不在数组A中的数时间复杂度：$$O(M+N)$$

    例如：A[1, 3, 4, 5, 6]、B[8, 2, 5, 3]，B排序后变为[2, 3, 5, 8]。

    ```
       i
       ↓
    A: 1  3  4  5  6
    B: 2  3  5  8
       ↑
       j
    ```
    ```cpp
    for(i=0,j=0; i<A.length && j<B.length; ) {
        if (B[j] < A[i])
        	打印B[j], j++
        else if (B[j] == A[i])
        	i++, j++
        else
        	i++
    }
    if(i>=A.length)
        打印B[j]后面所有元素;
    ```


